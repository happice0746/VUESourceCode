# diff算法

## Intro

vue为了优化内存和运行时间, 使用了虚拟dom(VNode)

在不断增添组件的过程中, VNodeTree在不断变化, 而diff算法就是来查询newVNodeTreeoldVNodeTree之间的difference的算法. 再基于这个算法, 我们再操作真实dom, 只改成有difference的地方从而尽可能的减少性能开销

## diff实现

在学习diff之前, 我们要先了解, _render, _update和patch是什么

### _render函数

_render函数你可以先理解为一个生成虚拟dom树的工具

先获取到编译阶段取得的_render函数

再使用_render函数来生成newVNodeTree

再运行_update函数把newVNodeTree的根节点传入该函数从而进行比较

`this._update(this._render())`

### _update函数

_update在收到一个newVNodeTree根节点后

会保存组件原先的VNodeTree, 并更新它

```JavaScript
function _update(newVNodeTree) {
    let oldVNodeTree = vm._vnode
    vm._vnode = newVNodeTree
}
```

### 比较

diff是基于父节点相同的节点来进行比较的:

    1           1 
   / \         / \ 
  2   3       5   2   
   old         new

在这里有两颗VNodeTree, 根节点为1
因为2和3与4和5的父节点都是1, 所以diff算法在此就会将 2和3 与 5和2 进行比较

**diff整体策略为：深度优先，同层比较**

在这个比较的过程中, 我们又是如何判断两个节点是否相等呢

#### 判等

```JavaScript
function sameVnode (n1, n2) {
  return (
    n1.type === n2.type &&      // 首先看类型是不是相同的
    n1.key === n2.key &&        // 再看key值是否相同
    (
      ( 
        n1.props === n2.props &&    // 不是组件节点时判断props是否相同
        n1._context === n2._context // 判断上下文是否相同
      ) || (
        isVNode(n1) && isVNode(n2) &&   // 如果是组件节点
        (
          (!n1.props && !n2.props) ||
          (n1.props && n2.props && normalizeProps(n1).keys === normalizeProps(n2).keys) // 看props是否相同
        )
      )
    )
  )
}
```

以上就是vue3中的sameVNode函数
在这个函数里首先会传入两个虚拟dom节点, 再对他们的一部分属性进行比较
再比较过后, 判断是否为组件节点, 再进行比较

再回到刚刚那个图我们可知, 左边的2 和 右边的2相同, 所以我们我们不需要删除一个2再新建一个2
而是保留它. 5和3不同, 所以我们要删除一个5, 再新建一个3

### patch函数

在获取到这些差异后, 我们可以收集成一个存储差异的对象并传给patch函数

patch函数在拿到差异后开始对真实dom进行操作, 结束后可挂载在父容器上, 从而实现页面的呈现


在diff实现的过程中：

尽量啥也别做

不行的话，尽量仅改动元素属性

还不行的话，尽量移动元素，而不是删除和创建元素

实在不行的话，删除和创建元素

当面试遇到diff相关问题, 以下是参考答案

当组件创建和更新时，vue会执行内部的update函数，该函数使用render函数生成的虚拟dom树，将新旧两树进行对比，找到差异点，最终更新到真实dom

对比差异的过程叫diff，vue在内部通过一个叫patch的函数完成该过程


>在对比时，vue采用深度优先、同级比较的方式进行比对。同级比较就是说它不会跨越结构进行比较
>
>在判断两个节点是否相同时，vue是通过虚拟节点的key和tag来进行判断的
>
>具体来说，首先对根节点进行对比，如果相同则将旧节点关联的真实dom的引用挂到新节点上，然后根据需要更新属性到真实dom，然后再对比其子节点数组；如果不相同，则按照新节点的信息递归创建所有真实dom，同时挂到对应虚拟节点上，然后移除掉旧的dom。
>
>在对比其子节点数组时，vue对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比，这样做的目的是尽量复用真实dom，尽量少的销毁和创建真实dom。如果发现相同，则进入和根节点一样的对比流程，如果发现不同，则移动真实dom到合适的位置。
>
>这样一直递归的遍历下去，直到整棵树完成对比。


参考文章(有图解):

1.[请阐述vue的diff算法](https://juejin.cn/post/6958292554047553549?searchId=2023091811013591F5E5334032FECF1F15)



2.[Vue3源码——从patch函数到组件更新](https://juejin.cn/post/7278613905379098679?searchId=20230918114559931B31F93285C0CA1D55)

3.[彻底理解vue的patch流程和diff算法](https://www.jianshu.com/p/e502002e1895)

4.chatgpt

5.vue.js的设计与实现





