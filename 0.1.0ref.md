# 响应系统的作用与实现

## 响应式数据与副作用函数

副作用函数: 间接或直接影响了其他函数的执行.如改变一个全局变量

响应式数据: 当值变化后, 副作用函数自动重新执行

这是一个较为精确的说法, 但也可以换成简单的说法

副作用函数就是会影响其他人的结果的函数

响应式数据就是会随着你操作实时改变的数据

### 基础响应式数据的应用场景

----------------

让我先来构造一个响应式数据的应用场景

左边是个盒子, 里面有个输入框, 右边也是个盒子, 里面有p标签

当我在输入框里输入东西的时候, 输入的内容会在右边展示出来

这个该如何实现呢? p标签的内容在网页加载的时候就已经敲定了呀

想必你已经和我一样, 脑袋里已经有了好几种解法

1.监听input事件

```javaScript
let input = document.getElementsByTagName('input')[0] // 获取tag名叫input的元素
let p = document.getElementsByTagName('p')[0] // 获取tag名叫p的元素
input.addEventListener('input',()=> {
    p.innerHTML = input.innerHTML
})
```

2.Proxy代理

```javaScript
let input = document.getElementsByTagName('input')[0] // 获取tag名叫input的元素
let p = document.getElementsByTagName('p')[0] // 获取tag名叫p的元素
const value = {
    text: '',
    // ......
}
const obj = new Proxy(value, {
    set(target,key,newVal) {    
        p.innerHTML = newVal
        return true
    }
})
obj.text = input.innerHTML
```
3.Object.defineProperty


```javaScript
// ES5前的写法, 我已经忘记怎么写了
```

其实这三种方法都是将p内的文字变成了响应式数据, 从而实现了实时更改

但是Vue的响应式数据会这么简单吗?

答案是否定的, 响应式数据的奥妙还有很多

来让我们看看我们使用的方法的缺陷

在第一种方法中, 如果有很多p标签需要拿到input中的值的话, 则需要取到很多dom, 编写很多赋值语句,十分耗时耗力

在第二种方法中, 如果我设置value中的其他属性, 也会触发set, 但我们要的只是当text属性改变时进行操作

所以我们需要一个更完善和强大的响应式系统来帮助我们完成这项工作

这个时候我们就要用到副作用函数

可能你现在仍然对副作用函数一知半解, 但是随着文章的慢慢张开, 你对副作用函数的认知会更清楚

```javaScript
let activeEffect
funtcion effect(fn) {
    activeEffect = fn
    fn()
}

const bucket = new Set()

const data = {
    text:'helloworld',
}

const obj = new Proxy(data, {
    get(target, key) {
        if(activeEffect) {
            bucket.add(activeEffect)
        }
        return target[key]
    },
    set(target, key, newVal) {
        target[key] = newVal
        bucket.forEach(fn=>fn())
        return true
    }
})

effect(()=>{
    console.log('注册副作用函数')
    document.body.innerText = obj.text
})
setTimeout(()=>{
    obj.text = 'hello flyingstudio'
},1000)
```
ok, 现在这是一个较为规整的响应式系统, 但是还远远没有结束, 因为我们还是没有解决一个问题

就是当我们在处理data中的其他值时, 还是会触发set, 从而遍历副作用函数桶

所以我们现在要改进的, 就是要建立起字段和副作用函数的关系

```JavaScript

let activeEffect

funtcion effect(fn) {
    activeEffect = fn
    fn()
}

const bucket = new Weapmap()
const target = {
    text:'helloworld'
}
const obj = new Proxy(target, {
    get(target, key) {
        if(!activeEffect) {
            return target[key]
        }
        const depsMap = bucket.get(target)
        if(!depsMap) {
            bucket.set(target, (depsMap = new Map()))
        }
        const deps = depsMap.get(key)
        if(!deps) {
            deps.set(key, (deps = new Set()))
        }
        deps.add(activeEffect)
        return target[key]
    },
    set(target, key, newVal) {
        target[key] = newVal
        const depsMap = bucket.get(target)
        if(!depsMap) return
        const effects = depsMap.get(key)
        effects && effects.forEach(fn=>fn())
    }
})
```